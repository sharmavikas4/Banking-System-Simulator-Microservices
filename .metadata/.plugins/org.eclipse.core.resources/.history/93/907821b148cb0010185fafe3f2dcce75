import java.util.concurrent.CompletableFuture;

import com.model.dto.account.AccountTransactionRequest;
import com.model.dto.account.AccountTransactionResponse;

@Service
public class AccountService {

    private static final Logger LOGGER = LoggerFactory.getLogger(AccountService.class);

    @Autowired
    private AccountServiceClient accountServiceClient;

    @CircuitBreaker(name = "accountServiceCB", fallbackMethod = "updateBalanceFallback")
    @Retry(name = "accountServiceRetry")
    @TimeLimiter(name = "accountServiceCB")
    public CompletableFuture<AccountTransactionResponse> updateBalance(
            String accountNumber,
            AccountTransactionRequest request
    ) {

        return CompletableFuture.supplyAsync(() -> {
            LOGGER.info("Calling Account Service for account={}, updateType={}",
                    accountNumber, request.getUpdateType());

            AccountTransactionResponse response =
                    accountServiceClient.updateBalance(accountNumber, request);

            LOGGER.info("Received response from Account Service for account={}, status={}",
                    accountNumber, response.status());

            return response;
        });
    }

    /**
     * FALLBACK (Triggered when CB is OPEN or Retry exhausted)
     */
    public CompletableFuture<AccountTransactionResponse> updateBalanceFallback(
            String accountNumber,
            AccountTransactionRequest request,
            Throwable exception
    ) {

        LOGGER.error("Fallback triggered for account={}, reason={}",
                accountNumber, exception.getMessage());

        AccountTransactionResponse fallbackResponse = new AccountTransactionResponse(
                "fallback-id",
                accountNumber,
                "Unavailable",
                request.getAmount(),
                TransactionStatus.FAILED
        );

        return CompletableFuture.completedFuture(fallbackResponse);
    }
}

package com.service.impl;

import java.time.LocalDateTime;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.exceptions.DatabaseException;
import com.model.Transaction;
import com.model.dto.TransactionRequest;
import com.model.dto.TransactionResponse;
import com.model.dto.account.AccountTransactionRequest;
import com.repository.TransactionRepository;
import com.service.TransactionServiceInterface;
import com.util.enums.TransactionStatus;
import com.util.enums.TransactionType;
import com.util.enums.UpdateType;
import com.util.feign.AccountServiceClient;
import com.util.transaction.GenerateTransactionId;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;

@Service
public class TransactionService implements TransactionServiceInterface {
	
	@Autowired
	private AccountServiceClient accountService;
	
	@Autowired
	private TransactionRepository transactionRepository;
	
	private Logger LOGGER = LoggerFactory.getLogger(TransactionService.class);
	
	private Transaction saveTransactionSafely(Transaction tx) {
	    try {
	        return transactionRepository.save(tx);
	    } catch (Exception e) {
	    	LOGGER.error("Database error while saving transactionId={} accountNumber={} amount={}",tx.getTransactionId(), tx.getAccountNumber(), tx.getAmount());
	    	throw new DatabaseException("Unable to save transaction at this time");
	    }
	}

	private TransactionResponse buildResponse(Transaction savedTransaction) {
		return TransactionResponse.builder()
									.accountNumber(savedTransaction.getAccountNumber())
									.amount(savedTransaction.getAmount())
									.timestamp(savedTransaction.getTimestamp())
									.status(savedTransaction.getStatus())
									.id(savedTransaction.getId())
									.transactionId(savedTransaction.getTransactionId())
									.type(savedTransaction.getType())
									.build();
	}
	
	@Override
	@CircuitBreaker(name = "accountServiceCB")
	@Retry(name = "accountServiceRetry")
	public TransactionResponse deposit(TransactionRequest transactionRequest) {
		String txnId = GenerateTransactionId.generate();
		LOGGER.info("Starting deposit txnId={} accountNumber={} amount={}",txnId, transactionRequest.accountNumber(), transactionRequest.amount());
		Transaction transaction = new Transaction();
		transaction.setAccountNumber(transactionRequest.accountNumber());
		transaction.setAmount(transactionRequest.amount());
		transaction.setType(TransactionType.DEPOSIT);
		transaction.setTransactionId(txnId);
		AccountTransactionRequest request = AccountTransactionRequest.builder()
																	 .amount(transactionRequest.amount())
																	 .updateType(UpdateType.DEPOSIT)
																	 .build();
		try {
			accountService.updateBalance(transactionRequest.accountNumber(), request);
			transaction.setStatus(TransactionStatus.SUCCESS);
			LOGGER.info("Deposit successful via Account Service txnId={} accountNumber={}", txnId, transactionRequest.accountNumber());
		}catch (RuntimeException e) {
			transaction.setStatus(TransactionStatus.FAILED);
			LOGGER.warn("Deposit failed during Account Service call txnId={} accountNumber={} reason={}",txnId, transactionRequest.accountNumber(), e.getMessage());
			transaction.setTimestamp(LocalDateTime.now());
			Transaction savedTransaction = saveTransactionSafely(transaction);
			LOGGER.warn("Failed deposit recorded txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
			throw e;
		}
		transaction.setTimestamp(LocalDateTime.now());
		Transaction savedTransaction = saveTransactionSafely(transaction);
		LOGGER.info("Deposit transaction stored successfully txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
		return buildResponse(savedTransaction);
	}
	@Override
	@CircuitBreaker(name = "accountServiceCB")
	@Retry(name = "accountServiceRetry")
	public TransactionResponse withdraw(TransactionRequest transactionRequest) {
		String txnId = GenerateTransactionId.generate();
        LOGGER.info("Starting withdrawal txnId={} accountNumber={} amount={}",txnId, transactionRequest.accountNumber(), transactionRequest.amount());
		Transaction transaction = new Transaction();
		transaction.setAccountNumber(transactionRequest.accountNumber());
		transaction.setAmount(transactionRequest.amount());
		transaction.setType(TransactionType.WITHDRAW);
		transaction.setTransactionId(txnId);
		AccountTransactionRequest request = AccountTransactionRequest.builder()
																	 .amount(transactionRequest.amount())
																	 .updateType(UpdateType.WITHDRAW)
																	 .build();
		try {
			accountService.updateBalance(transactionRequest.accountNumber(), request);
			transaction.setStatus(TransactionStatus.SUCCESS);
			LOGGER.info("Withdrawal successful via Account Service txnId={} accountNumber={}",txnId, transactionRequest.accountNumber());
		}catch (RuntimeException e) {
			transaction.setStatus(TransactionStatus.FAILED);
			LOGGER.warn("Withdrawal failed during Account Service call txnId={} accountNumber={} reason={}",txnId, transactionRequest.accountNumber(), e.getMessage());
			transaction.setTimestamp(LocalDateTime.now());
			Transaction savedTransaction = saveTransactionSafely(transaction);
			LOGGER.warn("Failed withdrawal recorded txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
			throw e;
		}
		transaction.setTimestamp(LocalDateTime.now());
		Transaction savedTransaction = saveTransactionSafely(transaction);
		LOGGER.info("Withdrawal transaction stored successfully txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
		return buildResponse(savedTransaction);
	}
}

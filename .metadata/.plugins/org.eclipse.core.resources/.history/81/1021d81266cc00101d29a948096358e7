package com.service.impl;

import java.time.LocalDateTime;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.exceptions.DatabaseException;
import com.exceptions.NoTransactionFoundException;
import com.model.Transaction;
import com.model.dto.TransactionRequest;
import com.model.dto.TransactionResponse;
import com.model.dto.TransferRequest;
import com.model.dto.TransferResponse;
import com.model.dto.account.AccountTransactionRequest;
import com.model.dto.notification.NotificationRequest;
import com.repository.TransactionRepository;
import com.service.TransactionServiceInterface;
import com.util.enums.TransactionStatus;
import com.util.enums.TransactionType;
import com.util.enums.UpdateType;
import com.util.feign.AccountServiceClient;
import com.util.feign.NotificationServiceClient;
import com.util.transaction.GenerateTransactionId;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;

@Service
public class TransactionService implements TransactionServiceInterface {
	
	@Autowired
	private AccountServiceClient accountService;
	
	@Autowired
	private TransactionRepository transactionRepository;
	
	private Logger LOGGER = LoggerFactory.getLogger(TransactionService.class);
	
	@Autowired
	private NotificationServiceClient notificationServiceClient;
	
	private void sendNotification(String message) {
	    try {
	        notificationServiceClient.sendNotification(new NotificationRequest(message));
	        LOGGER.info("Notification sent: {}", message);
	    } catch (Exception e) {
	        LOGGER.error("Failed to send notification: {}", message);
	    }
	}

	
	private Transaction saveTransactionSafely(Transaction tx) {
	    try {
	        return transactionRepository.save(tx);
	    } catch (Exception e) {
	    	LOGGER.error("Database error while saving transactionId={} accountNumber={} amount={}",tx.getTransactionId(), tx.getAccountNumber(), tx.getAmount());
	    	throw new DatabaseException("Unable to save transaction at this time");
	    }
	}

	private TransactionResponse buildResponse(Transaction savedTransaction) {
		return TransactionResponse.builder()
									.accountNumber(savedTransaction.getAccountNumber())
									.amount(savedTransaction.getAmount())
									.timestamp(savedTransaction.getTimestamp())
									.status(savedTransaction.getStatus())
									.id(savedTransaction.getId())
									.transactionId(savedTransaction.getTransactionId())
									.type(savedTransaction.getType())
									.build();
	}
	
	@Override
	@CircuitBreaker(name = "accountServiceCB")
	@Retry(name = "accountServiceRetry")
	public TransactionResponse deposit(TransactionRequest transactionRequest) {
		String txnId = GenerateTransactionId.generate();
		final String MDC_KEY = "correlationId";
	    MDC.put(MDC_KEY, txnId);
		try {
			LOGGER.info("Starting deposit txnId={} accountNumber={} amount={}",txnId, transactionRequest.accountNumber(), transactionRequest.amount());
			Transaction transaction = new Transaction();
			transaction.setAccountNumber(transactionRequest.accountNumber());
			transaction.setAmount(transactionRequest.amount());
			transaction.setType(TransactionType.DEPOSIT);
			transaction.setTransactionId(txnId);
			AccountTransactionRequest request = AccountTransactionRequest.builder()
																		 .amount(transactionRequest.amount())
																		 .updateType(UpdateType.DEPOSIT)
																		 .build();
			try {
				accountService.updateBalance(transactionRequest.accountNumber(), request);
				transaction.setStatus(TransactionStatus.SUCCESS);
				LOGGER.info("Deposit successful via Account Service txnId={} accountNumber={}", txnId, transactionRequest.accountNumber());
			}catch (RuntimeException e) {
				transaction.setStatus(TransactionStatus.FAILED);
				LOGGER.warn("Deposit failed during Account Service call txnId={} accountNumber={} reason={}",txnId, transactionRequest.accountNumber(), e.getMessage());
				transaction.setTimestamp(LocalDateTime.now());
				Transaction savedTransaction = saveTransactionSafely(transaction);
				LOGGER.warn("Failed deposit recorded txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
				String msg = String.format(
				        "TXID=%s | ACCOUNT=%s | AMOUNT=%.2f | TYPE=DEPOSIT | STATUS=FAILED",
				        transaction.getTransactionId(),
				        transaction.getAccountNumber(),
				        transaction.getAmount()
				);
				sendNotification(msg);
				throw e;
			}
			transaction.setTimestamp(LocalDateTime.now());
			Transaction savedTransaction = saveTransactionSafely(transaction);
			String msg = String.format(
			        "TXID=%s | ACCOUNT=%s | AMOUNT=%.2f | TYPE=DEPOSIT | STATUS=SUCCESS",
			        transaction.getTransactionId(),
			        transaction.getAccountNumber(),
			        transaction.getAmount()
			);
			sendNotification(msg);
			LOGGER.info("Deposit transaction stored successfully txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
			return buildResponse(savedTransaction);
		}finally {
			MDC.remove(MDC_KEY);
		}
	}
	@Override
	@CircuitBreaker(name = "accountServiceCB")
	@Retry(name = "accountServiceRetry")
	public TransactionResponse withdraw(TransactionRequest transactionRequest) {
		String txnId = GenerateTransactionId.generate();
		final String MDC_KEY = "correlationId";
	    MDC.put(MDC_KEY, txnId);
        try {
        	LOGGER.info("Starting withdrawal txnId={} accountNumber={} amount={}",txnId, transactionRequest.accountNumber(), transactionRequest.amount());
    		Transaction transaction = new Transaction();
    		transaction.setAccountNumber(transactionRequest.accountNumber());
    		transaction.setAmount(transactionRequest.amount());
    		transaction.setType(TransactionType.WITHDRAW);
    		transaction.setTransactionId(txnId);
    		AccountTransactionRequest request = AccountTransactionRequest.builder()
    																	 .amount(transactionRequest.amount())
    																	 .updateType(UpdateType.WITHDRAW)
    																	 .build();
    		try {
    			accountService.updateBalance(transactionRequest.accountNumber(), request);
    			transaction.setStatus(TransactionStatus.SUCCESS);
    			LOGGER.info("Withdrawal successful via Account Service txnId={} accountNumber={}",txnId, transactionRequest.accountNumber());
    		}catch (RuntimeException e) {
    			transaction.setStatus(TransactionStatus.FAILED);
    			LOGGER.warn("Withdrawal failed during Account Service call txnId={} accountNumber={} reason={}",txnId, transactionRequest.accountNumber(), e.getMessage());
    			transaction.setTimestamp(LocalDateTime.now());
    			Transaction savedTransaction = saveTransactionSafely(transaction);
    			LOGGER.warn("Failed withdrawal recorded txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
    			String msg = String.format(
    			        "TXID=%s | ACCOUNT=%s | AMOUNT=%.2f | TYPE=WITHDRAW | STATUS=FAILED",
    			        transaction.getTransactionId(),
    			        transaction.getAccountNumber(),
    			        transaction.getAmount()
    			);
    			sendNotification(msg);
    			throw e;
    		}
    		transaction.setTimestamp(LocalDateTime.now());
    		Transaction savedTransaction = saveTransactionSafely(transaction);
    		LOGGER.info("Withdrawal transaction stored successfully txnId={} status={}",savedTransaction.getTransactionId(), savedTransaction.getStatus());
    		String msg = String.format(
    		        "TXID=%s | ACCOUNT=%s | AMOUNT=%.2f | TYPE=WITHDRAW | STATUS=SUCCESS",
    		        transaction.getTransactionId(),
    		        transaction.getAccountNumber(),
    		        transaction.getAmount()
    		);
    		sendNotification(msg);
    		return buildResponse(savedTransaction);
        }finally {
        	MDC.remove(MDC_KEY);
		}
	}

	@Override
	@CircuitBreaker(name = "accountServiceCB")
	@Retry(name = "accountServiceRetry")
	public TransferResponse transfer(TransferRequest transferRequest) {
		String txnId = GenerateTransactionId.generate();
		final String MDC_KEY = "correlationId";
	    MDC.put(MDC_KEY, txnId);
	    try {
	    	String sourceAccount = transferRequest.sourceAccount();
		    String destinationAccount = transferRequest.destinationAccount();
		    Double amount = transferRequest.amount();
		    LOGGER.info("Starting transfer txnId={} fromAccount={} toAccount={} amount={}",txnId, sourceAccount, destinationAccount, amount);
		    Transaction transaction = new Transaction();
		    transaction.setTransactionId(txnId);
		    transaction.setSourceAccount(sourceAccount);
		    transaction.setDestinationAccount(destinationAccount);
		    transaction.setAmount(amount);
		    transaction.setType(TransactionType.TRANSFER);
		    boolean withdrawSucceeded = false;
		    try {
		    	AccountTransactionRequest withdrawRequest = AccountTransactionRequest.builder()
																	                .amount(amount)
																	                .updateType(UpdateType.WITHDRAW)
																	                .build();
				accountService.updateBalance(sourceAccount, withdrawRequest);
		        withdrawSucceeded = true;
		        LOGGER.info("Withdrawal from source account successful txnId={} sourceAccount={}", txnId, sourceAccount);
		        AccountTransactionRequest depositRequest = AccountTransactionRequest.builder()
																	                .amount(amount)
																	                .updateType(UpdateType.DEPOSIT)
																	                .build();
		        accountService.updateBalance(destinationAccount, depositRequest);
		        LOGGER.info("Deposit to destination account successful txnId={} destinationAccount={}", txnId, destinationAccount);
		        transaction.setStatus(TransactionStatus.SUCCESS);
		        String msg = String.format(
		                "TXID=%s | SRC=%s | DEST=%s | AMOUNT=%.2f | TYPE=TRANSFER | STATUS=SUCCESS",
		                transaction.getTransactionId(),
		                sourceAccount,
		                destinationAccount,
		                amount
		        );
		        sendNotification(msg);
		    }catch (RuntimeException e) {
		    	transaction.setStatus(TransactionStatus.FAILED);
		        LOGGER.warn("Transfer failed txnId={} fromAccount={} toAccount={} reason={}",txnId, sourceAccount, destinationAccount, e.getMessage());
		        if (withdrawSucceeded) {
		            try {
		                AccountTransactionRequest rollback = AccountTransactionRequest.builder()
															                        .amount(amount)
															                        .updateType(UpdateType.DEPOSIT)
															                        .build();
		                accountService.updateBalance(sourceAccount, rollback);
		                LOGGER.info("Rollback successful: amount refunded to sourceAccount={} txnId={}", sourceAccount, txnId);
		                String msg = String.format(
		                        "TXID=%s | SRC=%s | DEST=%s | AMOUNT=%.2f | TYPE=TRANSFER | STATUS=FAILED | ROLLBACK=SUCCESS",
		                        txnId,
		                        sourceAccount,
		                        destinationAccount,
		                        amount
		                );

		                sendNotification(msg);

		            } catch (RuntimeException ex) {
		                LOGGER.error("Rollback failed for sourceAccount={} txnId={}. Manual intervention required",sourceAccount, txnId, ex);
		                String msg = String.format(
		                        "TXID=%s | SRC=%s | DEST=%s | AMOUNT=%.2f | TYPE=TRANSFER | STATUS=FAILED | ROLLBACK=FAILED",
		                        txnId,
		                        sourceAccount,
		                        destinationAccount,
		                        amount
		                );
		                sendNotification(msg);
		            }
		        }
		        transaction.setTimestamp(LocalDateTime.now());
		        Transaction savedTransaction = saveTransactionSafely(transaction);
		        LOGGER.warn("Failed transfer recorded txnId={} status={}", savedTransaction.getTransactionId(), savedTransaction.getStatus());
		        String msg = String.format(
		                "TXID=%s | SRC=%s | DEST=%s | AMOUNT=%.2f | TYPE=TRANSFER | STATUS=FAILED",
		                txnId,
		                sourceAccount,
		                destinationAccount,
		                amount
		        );

		        sendNotification(msg);

		        throw e;
			}
		    transaction.setTimestamp(LocalDateTime.now());
		    Transaction savedTransaction = saveTransactionSafely(transaction);
		    LOGGER.info("Transfer transaction stored successfully txnId={} status={}", savedTransaction.getTransactionId(), savedTransaction.getStatus());
		    return TransferResponse.builder()
		    						.amount(savedTransaction.getAmount())
		    						.sourceAccount(savedTransaction.getSourceAccount())
		    						.destinationAccount(savedTransaction.getDestinationAccount())
		    						.timestamp(savedTransaction.getTimestamp())
		    						.status(savedTransaction.getStatus())
		    						.type(savedTransaction.getType())
		    						.transactionId(savedTransaction.getTransactionId())
		    						.id(savedTransaction.getId())
		    						.build();
	    }finally {
	    	MDC.remove(MDC_KEY);
		}
	}

	@Override
	public List<Transaction> getAllTransactions(String accountNumber) {
		LOGGER.info("Fetching all transactions for accountNumber={}", accountNumber);
		List<Transaction> transactions;
		try {
			transactions = transactionRepository.findDistinctByAccountNumberOrSourceAccountOrDestinationAccountOrderByTimestampDesc(accountNumber, accountNumber, accountNumber);
		}catch (Exception e) {
			LOGGER.error("Database error while fetching transactions for accountNumber={} reason={}", accountNumber, e.getMessage(), e);
	        throw new DatabaseException("Database error while fetching transactions for account number " + accountNumber);
		}
		if(transactions.isEmpty()) {
			LOGGER.warn("No transactions found for accountNumber={}", accountNumber);
	        throw new NoTransactionFoundException("No transaction found for account number " + accountNumber);
		}
		LOGGER.info("Found {} transactions for accountNumber={}", transactions.size(), accountNumber);
		return transactions;
	}
}
